22-10-11
反向输出输入的字符：
int main()
{
	int n=0;
	scanf("%d",&n);
	while(n!=0)
	{
		printf("%d",n%10);
		n=n/10;
	}
	return 0；
10-12
==是确定是否相等
= 是赋值
！= 非值

一：
Switch语句  整形语句  不能用float等
switch 语句中，必须有break或return 的结束语，不然会无限循环
case 同理，整形常量（不是变量）表达式
default  默认
default 与 case 无顺序要求
例：    
        int a=4;
        switch (a){
            case 1:
                System.out.println("1");
                break;
            case 2:
                System.out.println("2");
                break;
            case 3:
                System.out.println("3");
                break;
            default:
                System.out.println("default");
                break;
        }


For 循环会先完成命令再进行调整
While循环会先按流程走下去，按先后顺序

10-13
int arr[]={}是数组“”是字符
字符串末尾必有/0
strlen求字符串长度，不含/0，且需要头文件#include<string.h>
sleep函数是停顿n毫秒，并且需要头文件windows.h
system函数用来执行系统命令“cls”为清空屏幕，并且需要头文件stdlib.h
strcmp函数用来比较两个字符串相等，例strcmp(password,"123456")  例：strcmp(input,"我是猪")==0  



char定义字符
int 定义整形
static 修饰静态变量
 
scanf ("")引号内什么内容，键盘就要输入什么内容
例：("%d,%d,%d,&a,&b,&c\n") 在输入的时候   , 和空格不能省略，而且会区分中英文


 &&表示并且
||表示或者

10-14
sqrt        开平方的数学库函数，需要引用数学头文件<math.h>
printf("%d")中，%d可以为%2d，意为2个位的数字，若为单数用空白补充，也可%-2d，意为向左对齐的2位数字
rand   生成随机数的函数

10-15
Function - 函数
库函数：本身自带的函数
null=/0
strcpy(x,y) 是复制函数，x是对象，y是被复制的，需头文件string.h，包括/0一起复制过去，/0是字符串的结束标志
memory- 内存  设置 例： memset(arr,'*',5) 意为将字符串arr内前五位字符换为*
计算时需要考虑优先级  例：   *p++  实际无变化，应改为(*p)++
printf的返回值 是 打印字符的个数
            ☆引头文件时   系统的用<>，自己定义的用“”

10-16
                                     ☆数组传参时，传过去的不是整个数组，而是第一个元素的地址，所以应该在外部计算好了之后再进行传参
	        但是有两个例外：
		1sizeof(数组名) - 数组名表示整个数组 - 计算的是整个数组的大小单位是字节
                2.&数组名 - 数组名表示整个数组 - 取出的是整个数组的地址
创建数组时，字符数组用""，数字用{}，例：char arr[]="......"
传进函数的值要注意先后顺序 例： my_strlen(x+1)与my_strlen(x++),前者是传入x+1的值，后者是先传入x再++

10-17
str[left]可以换成*(str+lest) 效果一样   前者是数组指定地址，后者是指针取地址

10-18
数组是通过下标来访问的
数组的大小是可以通过计算得到的
打印地址用的是%p
一维数组带内存中是连续存放的，二维数组在内存中也是连续存放的。

随着数组下标的增长，地址是由低到高变化的
                                     ☆数组名是数组首元素的地址  例：int*p=arr  *p存放的是数组arr首元素的地址
整形数组里有\0 ，字符数组里没有。

10-19
do while循环
do{}
while(一个变量或者常量)，while（中若是1，则为真，循环继续，若为假（值是0或其他判断条件），则跳出循环）
10-20
 Today learn Tic Tac Toe      （今天学习了井字棋）
 C语言一定是门逻辑性强的语言。
10-21
井字棋二刷
10-22
拟写扫雷
10-23

正数的原码补码反码都一样!?!!?!?!?!?!?
移位操作符（移动的数值不存在负值和0）
a<< 1:把a的二进制位向左移动一位   --左边丢弃，右边补0；
a>> 1:把a的二进制位向右移动一位   --算术右移，要考虑负数的原码，反码，补码。
但是a 的值没有发生变化
算术右移：右边丢弃，左边补原符号位
逻辑右移：右移丢弃，左边补0
VS的右移操作符采用的是算术右移，而不是逻辑右移
位操作符（他们的操作值必须为整数）
1.按（二进制）位与
c=a&b       0000000000011
                  0000000000101        结果：c=00000000000001
2.按（二进制）位或
c=a|b    a与b值同上        结果c=00000000111
3.按（对应的二进制）位异或
规则：相同为0，相异为1
c=a^b    a与b值同上        结果c=00000000110

交换值的最简单方法：
例： int a=3 ;int b=5;
a=a^b;
b=a^b;
a=a^b;
详解：
a=00000000011
b=00000000101
^a=00000000110
^b=00000000011
^a=00000000101

10-24
~补码按位取反

后置++，先使用，再++；前置++，先++，再使用；
-- 同理

int a =10;
printf("%p\n",&a);
int *pa=&a;    pa 是用来存放地址的 -pa就是一个指针变量，切pa前面的类型与a 的类型相同
*pa=20//实意是把a的值设为20;*是解引用操作符，间接访问操作符
(并且数组传参的时传过去的是首元素的地址)


☆☆☆☆☆☆☆☆☆☆
一定要注意真假值
☆☆☆☆☆☆☆☆☆☆

printf("%d\n",arr[4])其中的[]就是下标引用操作符
[]的操作数是两个：arr ， 4

int ret=Add(a,b) ()-函数调用操作符

结构成员访问操作符：  .    ->

10-25
空

10-26
两个指针相减得到的是两个指针之间的元素的个数

            ☆解引用是指：通过指针，找到对应的内存和内存中的数据。我们可以通过解引用访问或修改指针指向的内存内容。
              & 与 * 互为逆运算。& ，其作用是取变量的地址；* ，其作用是取地址对应的内存，内存长度由指针类型确定

int a=10;
int*pa=&a;
二级指针  int**ppa=&pa;
*p	pa==pa
**ppa==a

10-27
‘ ’内只能存放一个元素    
“ ”内存放多种元素，具体看数组大小

指针-指针得到的是两个指针之间的元素个数（前提是两个指针指向的是同一个空间）


每一个函数调用都会在内存的栈区中开辟一块空间
传参时计算器是从右向左传参

↑≠↓
局部变量是放在栈区上的 
栈区内存的使用习惯是：先使用高地址空间，再使用低地址空间

内存内 存放的是二进制，但是展示出来的是十六进制


——————————————————————————————————————————————————————————————————————————————————————————————————————————
模拟实现字符串相关函数
void my_strcpy(char* dest,const char* src)

strcpy  拷贝函数
assert（） 断言  ()内的内容若为假，则报错    需要引头<assert.h>  
const 防止写反判断条件
以及const修饰变量的时候，这个变量被称为常变量，不能被修改，但本质上还是变量，const修饰指针变量的时候，如果放在*的左边，表示指针指向的内容，是不能通过指针来改变的，但是指针变量本身是可以修改的
——————————————————————————————————————————————————————————————————————————————————————————————————————————

10-28
标准的库函数需要注意的的四个大点
1.const
2.assert断言
3.函数的内容
4.返回类型

short指针+1 跳过两个字节
int指针+1 跳过四个字节

%s打印数组内容时要注意数组有无\0结束标志

10-29
指针数组≠数组指针
int *parr[10]≠int(*parr)[10]

10-30
10-31
sizeof算出的结果的类型是unsigned int (在比大小的时候要注意)
有符号整形和无符号整形进行运算时，要先把有符号整形转化为无符号整形char *arr="abcdef"   这是个常量字符串，无法更改""内内容

2022-11-1

如何将二级指针传参
1.int *pa=&a
test(&pa)  -->传一级指针的地址
2.int *arr[10]={0}
test(arr)  -->传存放一级指针的数组

数组名 !=&数组名
函数名 ==&函数名

11-2

int (*pf)(int,int)=Add;
进行重定义时以下三种都可以
int ret=(*pf)(3,5);
int ret=pf(3,5);
int ret=Add(3,5);

//////////////了解////////////////
((void(*)())0)()
解读：调用0地址处的函数，该函数无参，返回类型是void
1.void(*)() - 函数指针类型
2.(void(*)())0 - 对0进行强制类型转换，被解释为一个函数地址
3.*(void(*)())0 - 对0地址进行了解引用操作
4.(*(void(*)())0)() - 调用0地址处的 函数
//////////////了解////////////////



