☆☆☆☆☆

1.当我们在谈论程序执行的时候，计算机内存
大部分时候我们说的是随机储存器也就是RAM

2.多维数组本质上是数组的数组

☆☆☆☆☆

22-10-11
反向输出输入的字符：
int main()
{
	int n=0;
	scanf("%d",&n);
	while(n!=0)
	{
		printf("%d",n%10);
		n=n/10;
	}
	return 0；
10-12
==是确定是否相等
= 是赋值
！= 非值

一：
Switch语句  整形语句  不能用float等
switch 语句中，必须有break或return 的结束语，不然会无限循环
case 同理，整形常量（不是变量）表达式
default  默认
default 与 case 无顺序要求
例：    
        int a=4;
        switch (a){
            case 1:
                System.out.println("1");
                break;
            case 2:
                System.out.println("2");
                break;
            case 3:
                System.out.println("3");
                break;
            default:
                System.out.println("default");
                break;
        }


For 循环会先完成命令再进行调整
While循环会先按流程走下去，按先后顺序

10-13
int arr[]={}是数组“”是字符
字符串末尾必有/0
len求字符串长度，不含/0，且需要头文件#include<string.h>
sleep函数是停顿n毫秒，并且需要头文件windows.h
system函数用来执行系统命令“cls”为清空屏幕，并且需要头文件stdlib.h
strcmp函数用来比较两个字符串相等，例strcmp(password,"123456")  例：strcmp(input,"我是猪")==0  



char定义字符
int 定义整形
static 修饰静态变量
 
scanf ("")引号内什么内容，键盘就要输入什么内容
例：("%d,%d,%d,&a,&b,&c\n") 在输入的时候   , 和空格不能省略，而且会区分中英文


 &&表示并且
||表示或者

10-14
sqrt        开平方的数学库函数，需要引用数学头文件<math.h>
printf("%d")中，%d可以为%2d，意为2个位的数字，若为单数用空白补充，也可%-2d，意为向左对齐的2位数字
rand   生成随机数的函数

10-15
Function - 函数
库函数：本身自带的函数
null=/0
strcpy(x,y) 是复制函数，x是对象，y是被复制的，需头文件string.h，包括/0一起复制过去，/0是字符串的结束标志
memory- 内存  设置 例： memset(arr,'*',5) 意为将字符串arr内前五位字符换为*
计算时需要考虑优先级  例：   *p++  实际无变化，应改为(*p)++
printf的返回值 是 打印字符的个数
            ☆引头文件时   系统的用<>，自己定义的用“”

10-16
                                     ☆数组传参时，传过去的不是整个数组，而是第一个元素的地址，所以应该在外部计算好了之后再进行传参
	        但是有两个例外：
		1sizeof(数组名) - 数组名表示整个数组 - 计算的是整个数组的大小单位是字节
                2.&数组名 - 数组名表示整个数组 - 取出的是整个数组的地址
创建数组时，字符数组用""，数字用{}，例：char arr[]="......"
传进函数的值要注意先后顺序 例： my_strlen(x+1)与my_strlen(x++),前者是传入x+1的值，后者是先传入x再++

10-17
str[left]可以换成*(str+lest) 效果一样   前者是数组指定地址，后者是指针取地址

10-18
数组是通过下标来访问的
数组的大小是可以通过计算得到的
打印地址用的是%p
一维数组带内存中是连续存放的，二维数组在内存中也是连续存放的。

随着数组下标的增长，地址是由低到高变化的
                                     ☆数组名是数组首元素的地址  例：int*p=arr  *p存放的是数组arr首元素的地址
整形数组里有\0 ，字符数组里没有。

10-19
do while循环
do{}
while(一个变量或者常量)，while（中若是1，则为真，循环继续，若为假（值是0或其他判断条件），则跳出循环）
10-20
 Today learn Tic Tac Toe      （今天学习了井字棋）
 C语言一定是门逻辑性强的语言。
10-21
井字棋二刷
10-22
拟写扫雷
10-23

正数的原码补码反码都一样!?!!?!?!?!?!?
移位操作符（移动的数值不存在负值和0）
a<< 1:把a的二进制位向左移动一位   --左边丢弃，右边补0；
a>> 1:把a的二进制位向右移动一位   --算术右移，要考虑负数的原码，反码，补码。
但是a 的值没有发生变化
算术右移：右边丢弃，左边补原符号位
逻辑右移：右移丢弃，左边补0
VS的右移操作符采用的是算术右移，而不是逻辑右移
位操作符（他们的操作值必须为整数）
1.按（二进制）位与
c=a&b       0000000000011
                  0000000000101        结果：c=00000000000001
2.按（二进制）位或
c=a|b    a与b值同上        结果c=00000000111
3.按（对应的二进制）位异或
规则：相同为0，相异为1
c=a^b    a与b值同上        结果c=00000000110

交换值的最简单方法：
例： int a=3 ;int b=5;
a=a^b;
b=a^b;
a=a^b;
详解：
a=00000000011
b=00000000101
^a=00000000110
^b=00000000011
^a=00000000101

10-24
~补码按位取反

后置++，先使用，再++；前置++，先++，再使用；
-- 同理

int a =10;
printf("%p\n",&a);
int *pa=&a;    pa 是用来存放地址的 -pa就是一个指针变量，切pa前面的类型与a 的类型相同
*pa=20//实意是把a的值设为20;*是解引用操作符，间接访问操作符
(并且数组传参的时传过去的是首元素的地址)


☆☆☆☆☆☆☆☆☆☆
一定要注意真假值
☆☆☆☆☆☆☆☆☆☆

printf("%d\n",arr[4])其中的[]就是下标引用操作符
[]的操作数是两个：arr ， 4

int ret=Add(a,b) ()-函数调用操作符

结构成员访问操作符：  .    ->

10-25
空

10-26
两个指针相减得到的是两个指针之间的元素的个数

            ☆解引用是指：通过指针，找到对应的内存和内存中的数据。我们可以通过解引用访问或修改指针指向的内存内容。
              & 与 * 互为逆运算。& ，其作用是取变量的地址；* ，其作用是取地址对应的内存，内存长度由指针类型确定

int a=10;
int*pa=&a;

tmp = arr[t];int**ppa=&pa;
*p	pa==pa
**ppa==a

10-27
‘ ’内只能存放一个元素    
“ ”内存放多种元素，具体看数组大小

指针-指针得到的是两个指针之间的元素个数（前提是两个指针指向的是同一个空间）


每一个函数调用都会在内存的栈区中开辟一块空间
传参时计算器是从右向左传参

↑≠↓
局部变量是放在栈区上的 
栈区内存的使用习惯是：先使用高地址空间，再使用低地址空间

内存内 存放的是二进制，但是展示出来的是十六进制


——————————————————————————————————————————————————————————————————————————————————————————————————————————
模拟实现字符串相关函数
void my_strcpy(char* dest,const char* src)

strcpy  拷贝函数
assert（） 断言  ()内的内容若为假，则报错    需要引头<assert.h>  
const 防止写反判断条件
以及const修饰变量的时候，这个变量被称为常变量，不能被修改，但本质上还是变量，const修饰指针变量的时候，如果放在*的左边，表示指针指向的内容，是不能通过指针来改变的，但是指针变量本身是可以修改的
——————————————————————————————————————————————————————————————————————————————————————————————————————————

10-28
标准的库函数需要注意的的四个大点
1.const
2.assert断言
3.函数的内容
4.返回类型

short指针+1 跳过两个字节
int指针+1 跳过四个字节

%s打印数组内容时要注意数组有无\0结束标志

10-29
指针数组≠数组指针
int *parr[10]≠int(*parr)[10]

10-30
10-31
sizeof算出的结果的类型是unsigned int (在比大小的时候要注意)
有符号整形和无符号整形进行运算时，要先把有符号整形转化为无符号整形char *arr="abcdef"   这是个常量字符串，无法更改""内内容

2022-11-1

如何将二级指针传参
1.int *pa=&a
test(&pa)  -->传一级指针的地址
2.int *arr[10]={0}
test(arr)  -->传存放一级指针的数组

数组名 !=&数组名
函数名 ==&函数名

11-2

int (*pf)(int,int)=Add;
进行重定义时以下三种都可以
int ret=(*pf)(3,5);
int ret=pf(3,5);
int ret=Add(3,5);

//////////////了解////////////////
((void(*)())0)()
解读：调用0地址处的函数，该函数无参，返回类型是void
1.void(*)() - 函数指针类型
2.(void(*)())0 - 对0进行强制类型转换，被解释为一个函数地址
3.*(void(*)())0 - 对0地址进行了解引用操作
4.(*(void(*)())0)() - 调用0地址处的 函数
//////////////了解////////////////

11-3
int arr[10]
//数组元素类型 - int
//arr数组的类型是 int[10]

一个学到的基础构造结构体（长知识啦）
struct Stu
{
char name[20];
int age;
};
struct Stu s[]={{"zhangsan",30},{"lisi",34},{"wangwu",20}}

11-4
1.sizeof（数组名）（记住是要单独放在括号内，不能加其他内容）
2.&数组名
除以上两种情况，其他都是数组名表示首元素的地址
数组名表示首元素的地址
数组名表示首元素的地址
数组名表示首元素的地址
数组名表示首元素的地址
数组名表示首元素的地址
数组名表示首元素的地址
数组名表示首元素的地址
数组名表示首元素的地址
数组名表示首元素的地址
数组名表示首元素的地址
数组名表示首元素的地址
数组名表示首元素的地址
数组名表示首元素的地址


*****字符所占空间的大小是一个字节
但是一个空间的地址编号是四个字节*****
地址大小≠元素空间大小

11-5

//void print(int (*W)[2][2])
//{
//	int i, j, k;
//	for (i = 0; i < 3; i++)
//	{
//		for (j = 0; j < 2; j++)
//		{
//			for (k = 0; k < 2; k++)
//			{
//				printf("%d ", W[i][j][k]);
//			}
//		}
//	}
//}
//int main()
//{
//	int W[3][2][2] = { {{2,7},{4,9}},{{1,5},{3,10}},{{6,11},{8,12}} };
//	print(W);
//	int B[2][3] = { {2,3,6},{4,5,8} };
//	int(*P)[3] = B;
//	printf("%d\n", *P[0] + 1);
//	printf("%d\n", *(*B + 1));
//	printf("%d\n", *(*B + 1) + 2);
//	return 0;
//}



	//B[i][j]=*(B[i]+j)=*(*(B+i)+j);
	//&B[1][0]=*(B+1)=B[1]=B+1=&B[1];
	//*********************多维数组本质上是数组的数组*********************
	//B是一个二维数组，是一位数组的数组，所以B返回的是指向一维数组的指针（返回的不是整形指针！≠int*p=B）：int(*P)[3]=B;即指向包含3个整形元素的一位数组的指针
	//B和*B都返回指针，不同点在于，B返回一个指向一维数组的指针，而*B返回一个指向整形的指针，指针类型会在你解引用或者尝试做指针算术的时候起作用
	//例B[i][j]=*(B[i]+j)此时B如果是一维数组那么B[i]返回的是整形指针，也就是指向B[i]的第一个整形数的指针，然后+j进行指针算术运算，得到的是在B[i]的索引位置是j 的整形指针，解引用得到这个整形数的值
	//再者B[i][j]=*(*(B+i)+j)此时B如果是一维数组，那么(B+i)也是一维数组的指针，解引用会得到一个一维数组，返回的是那个数组的首元素的地址。
	//C语言中内存的堆≠数据结构中的堆

11-6
int *ptr2=(int*)((int)a+1)	整形+1 只向前加了一个字节 
     例      地址为0x20-->转换为int类型 则为32  int+1=33-->转化为int*则为0x21  

指针-指针=两个指针之间的元素个数



11-6--11-12
-------长度不受限制的字符串函数
strlen（数组）求字符串长度
strcpy（目的地，源头）拷贝字符串
strcat（目的地，源头）字符串追加

-------长度受限的字符串函数
strncpy
strncpy
strncat4

---------
strstr(待查找,需查找)在一个字符数组中查找是否包含另外一个数组
strtok 切割字符串
strerror 显示错误信息   头文件errno.h


--------内存函数
memcpy     拷贝不重叠的内存
memmove    可以处理内存重叠的情况
memmcmp     内存比较
memset      内存设置  以字节为单位设置内存   适合字符数组

在结构体内部中创建的变量，是全局的，在main中是局部的
结构体内可以包含结构体变量（但不能包含本身）

结构体内存对齐
#pragma pack()可以改变默认对齐数
offsetof(struct X,X) 计算偏移量  需要stdeef.h头文件
传值调用占空间 ××××
传址调用             √√√√
位段             int _a:2    意为（int）开辟4个字节，a占2个bit位节省空间，但不能超过int 的最大值     char 同理
但位段有许多不确定性，无法跨平台使用，可移植程序应避免使用位段

一个字节内部和大小端是没有关系的，大小端是字节的顺序，而不是字节内部

enum 枚举类型（但是他的值是整形）
enum Color
{
RED,GREEN,BLUE
};
//RED默认值是0，GREEN是2...往下增，默认递增1
//这些都是常量，只能赋初值
int main()
{enum Color c = BLUE;}

枚举的优点
比#define 好，有类型检查
让代码有可读性和可维护性，更具有联想性
防止命名污染
便于调试
使用方便 
  

联合体（也叫共用体）
在同一时间只能选一个成员

高位放在低地址处        大端存储模式


动态内存开辟
在堆上开辟
malloc(size)         申请空间  单位字节
例 Int*p=(int*)malloc(10*sizeof(int))
calloc(num,size)     申请空间的同时还会将所有的值初始化为0
例       calloc(10,4)            
free()          只能释放堆区的空间
例：free(p)    将p指向的空间清除     
  p=NULL      需手动把p置为空指针       
realloc(之前开辟的内存空间,new_size)         重新开辟空间
有三种情况：
①：后面开辟的空间足够，返回的是原地址
②：后面开辟的空间不足够，会重新找一个空间足够的新的地址，然后返回的是新的地址，但之前的地址的值仍存在，需用free释放
③：若找不到合适的空间，则返回空指针，所以需进行判断是否为空指针
同时realloc(NULL,40)这里功能类似于malloc


动态内存的常见错误
1.对NULL指针的解引用操作
解决：对malloc函数的返回值，做判空处理
2.对动态开辟的空间进行越界访问
解决：在写代码的时候多注意访问动态内存的位置是否存在
3.使用free释放非动态开辟的空间
4.使用free释放动态内存中的一部分
例：for(i=0;;i<5;i++)
{*p++=i;}
free(p)此时p指向的是初地址的后第五个位置，所以无法释放前五个位置，只释放了一部分
5.对同一块动态开辟的空间多次释放
解决：在释放后，使指针置为空指针
6.动态开辟的空间忘记释放（会导致内存泄露！！！）
解决：malloc和free成对使用	  

11-13--11.14

文件
int main()
{
file*pf=fopen("text.txt","r")
if(pf==NULL)  perror("fopen") ; teturn 1;
}
fcolse（pf）
pf=NULL
程序文件  .c .exe .obj
数据文件  程序运行时读写的数据
前缀(FILE*pe=)  fopen (目标文件，打开方式)
fclose(指向目标文件的指针)
记得将指针置为空指针
打开方式：（主要三个）
"r"只读	
"w"只写         每次写的时候会清空数据
"a"追加
“wb”以 二进制写入
打开目标文件的时候路径记得加上双斜杠
\是转义字符

文件的顺序读写
字符输出函数           ：fputc(需要输出的内容，流）
字符输入函数（读取函数）  ：fgetc(流）


读一串数字fgets（接收的,最多读取的个数（读取的是n-1）,给读的指针）
写一串数字fputs（写入的内容，给读的指针（流））


格式化写文件
fprintf(流，后面与printf一样)
格式化读文件
fscanf(流，后面与scanf一样）

二进制写文件
fwrite（写入的内容，写入的大小，写入数据的个数（一般写一个），流（写入的地方）	
写入的内容是看不懂的，但是机器能够识别

二进制读文件
fread（与fwrite相同，但是是从流里读数据然后放在（写入的内容中），是相反的）



流stream
C语言程序，只要运行起来，就默认打开了3个流，类型都是FILE*：
stdin 标准输入流-键盘
stdout 标准输出流-屏幕
stderr 标准错误流-屏幕



scanf 针对标准输入的格式化的输入语句-stdin
fscanf 针对所有输入流的格式化的输入语句 -stdin/文件
sscanf 从字符串中读取出一个结构体数据

printf 针对标准输出的格式化的输出语句-stdout
fprintf 针对所有输出流的格式化的输出语句 -stdout/文件
sprintf 把一个格式化的数据，转化成字符串




文件的随机读写
fseek(流（指向文件的指针）,偏移量（以字节为单位）,起始位置)  调整文件指针
起始位	置有三个值：SEEK_CUR(当前位置)、SEEK_END(文件末尾）、SEEK_SET(文件起始位置）
ftell(流（指向文件的指针）)   计算与流的偏移量
rewind  让指针回到起始位置


文本文件和二进制文件
数据如果不加转换的输出到外存，就是二进制文件
一个数组在文件中怎么存储的
字符一律以ASCII形式存储，数值型数据既可以以ASCII存储，也可以使用二进制形式存储
如果有整数1000，如果以ASCII码形式输出到硬盘，则占5个字节，如果以二进制，则占4个字节
“wb”二进制形式写入


文件读取结束的判定
在读取过程中，不能用feof函数的返回值直接用来判断文件是否结束
 而是应用与当文件读取结束的时候，判断是读取失败结束的还是遇到文件尾结束的。


文本文件读取是否结束，判断是否为EOF
1.fgetc 函数在读取结束的时候，会返回EOF
正常读取的时候，返回的是读取到的字符的ASCII码值
2.fgets 函数在读取结束的时候，会返回NULL
正常读取的时候，返回存放字符串的空间起始地址
3.fread函数在读取的时候，返回的是实际读取到的完整元素的个数
如果发现读取到的完整的元素的个数小于指定的元素个数，这就是最后一次读取了。

缓冲区的概念
int main ()
{
FILE* pf = fopen ( "test.txt", "w" );
fputs ( "abcdef", pf);/l先将代码放在输出缓冲区
printf("睡眠10秒-已经写数据了，打开test.txt文件，发现文件没有内容\n");
sleep ( 10000);
printf("刷新缓冲区\n");
fflush(pf);//刷新缓冲区时，才将输出缓冲区的数据写到文件（磁盘)
//注:fflush在高版本的vs上不能使用了
printf("再睡眠1o秒-此时，再次打开test.txt文件，文件有内容了\n");
sleep (10000) ;
fclose(pf);
//注:fclose在关闭文件的时候，也会刷新缓冲区
pf = NULL;
return 0;
}



EOF=-1
if（p=NULL）   可以写成if（！p）

